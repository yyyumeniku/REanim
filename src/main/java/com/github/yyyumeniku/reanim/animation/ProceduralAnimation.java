package com.github.yyyumeniku.reanim.animation;

import java.util.function.BiFunction;

import com.github.yyyumeniku.reanim.api.IAnimation;
import com.github.yyyumeniku.reanim.api.IPose;

import net.minecraft.util.ResourceLocation;

/**
 * Animation generated by a function (e.g., sine waves).
 * Most flexible for dynamic animations.
 * 
 * Example - Climbing animation:
 * <pre>{@code
 * ProceduralAnimation climbAnimation = new ProceduralAnimation(
 *     new ResourceLocation("mymod", "climb"),
 *     20, // 1 second loop
 *     true, // looping
 *     (progress, partialTicks) -> {
 *         float armSwing = MathHelper.sin(progress * MathHelper.PI * 2) * 0.9f;
 *         float legSwing = MathHelper.sin(progress * MathHelper.PI * 2 + MathHelper.PI) * 0.6f;
 *         
 *         return PoseBuilder.create()
 *             .rightArm(-2.2f + armSwing, -0.2f, 0.35f)
 *             .leftArm(-2.2f - armSwing, 0.2f, -0.35f)
 *             .rightLeg(legSwing + 0.2f, 0, 0)
 *             .leftLeg(-legSwing + 0.2f, 0, 0)
 *             .body(0.25f, 0, 0)
 *             .head(-0.15f, 0, 0)
 *             .build();
 *     }
 * );
 * }</pre>
 */
public class ProceduralAnimation implements IAnimation {
    
    private final ResourceLocation id;
    private final int durationTicks;
    private final boolean looping;
    private final BiFunction<Float, Float, IPose> poseFunction;
    private final int priority;
    private final float speed;
    
    /**
     * Create a procedural animation.
     * @param id Unique animation ID
     * @param durationTicks Duration of one cycle in ticks (20 = 1 second)
     * @param looping Whether the animation loops
     * @param poseFunction Function that generates pose from (progress, partialTicks)
     */
    public ProceduralAnimation(
            ResourceLocation id,
            int durationTicks,
            boolean looping,
            BiFunction<Float, Float, IPose> poseFunction) {
        this(id, durationTicks, looping, poseFunction, 0, 1.0f);
    }
    
    /**
     * Create a procedural animation with priority and speed.
     * @param id Unique animation ID
     * @param durationTicks Duration of one cycle in ticks
     * @param looping Whether the animation loops
     * @param poseFunction Function that generates pose
     * @param priority Animation priority (higher = takes precedence)
     * @param speed Playback speed multiplier
     */
    public ProceduralAnimation(
            ResourceLocation id,
            int durationTicks,
            boolean looping,
            BiFunction<Float, Float, IPose> poseFunction,
            int priority,
            float speed) {
        this.id = id;
        this.durationTicks = Math.max(1, durationTicks);
        this.looping = looping;
        this.poseFunction = poseFunction;
        this.priority = priority;
        this.speed = speed;
    }
    
    @Override
    public ResourceLocation getId() {
        return id;
    }
    
    @Override
    public IPose getPoseAtProgress(float progress, float partialTicks) {
        return poseFunction.apply(progress, partialTicks);
    }
    
    @Override
    public int getDurationTicks() {
        return durationTicks;
    }
    
    @Override
    public boolean isLooping() {
        return looping;
    }
    
    @Override
    public int getPriority() {
        return priority;
    }
    
    @Override
    public float getSpeed() {
        return speed;
    }
}
